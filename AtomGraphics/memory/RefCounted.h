//
// Created by neo on 2018/11/13.
// Copyright (c) 2018 neo. All rights reserved.
//

#ifndef ATOMGRAPHICS_REFCOUNTED_H
#define ATOMGRAPHICS_REFCOUNTED_H

#include <memory>
#include <atomic>
#include "FastMalloc.h"
#include "base/AtomMacros.h"
#include "ScopedRefPtr.h"

namespace AtomGraphics {

// This base class holds the non-template methods and attributes.
// The RefCounted class inherits from it reducing the template bloat
// generated by the compiler (technique called template hoisting).

namespace subtle {

class RefCountedBase {

public:

    explicit RefCountedBase(StartRefCountFromZeroTag) : m_refCount(0) {}

    explicit RefCountedBase(StartRefCountFromOneTag) : m_refCount(1) {}

    void ref() const {
        ++m_refCount;
    }

    bool hasOneRef() const {
        return m_refCount == 1;
    }

    unsigned refCount() const {
        return m_refCount;
    }

    void relaxAdoptionRequirement() {}

protected:

    ~RefCountedBase() {}

    // Returns whether the pointer should be freed or not.
    bool derefBase() const {

        unsigned tempRefCount = m_refCount - 1;
        if (!tempRefCount) {
            return true;
        }
        m_refCount = tempRefCount;
        return false;
    }

private:

    mutable unsigned m_refCount;
};


class RefCountedThreadSafeBase {

public:
    explicit constexpr RefCountedThreadSafeBase(StartRefCountFromZeroTag) {}

    explicit constexpr RefCountedThreadSafeBase(StartRefCountFromOneTag)
            : m_refCount(1) {

    }

    void ref() const {
        ++m_refCount;
    }

    bool hasOneRef() const {
        return m_refCount == 1;
    }

    unsigned refCount() const {
        return m_refCount;
    }

protected:

    ~RefCountedThreadSafeBase() {}

    // Returns whether the pointer should be freed or not.
    bool derefBase() const {
        return m_refCount.fetch_sub(1, std::memory_order_acq_rel) == 1;
    }

private:
    mutable std::atomic_uint m_refCount{0};

};

} // namespace subtle

#define REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE()             \
  static constexpr AtomGraphics::subtle::StartRefCountFromOneTag \
      kRefCountPreference = AtomGraphics::subtle::kStartRefCountFromOneTag

template<typename T>
class RefCounted : public subtle::RefCountedBase {
AT_MAKE_NONCOPYABLE(RefCounted);
AT_MAKE_FAST_ALLOCATED;

public:
    static constexpr subtle::StartRefCountFromZeroTag kRefCountPreference =
            subtle::kStartRefCountFromZeroTag;

    void deref() const {
        if (derefBase())
            delete static_cast<const T *>(this);
    }

protected:

    RefCounted() : subtle::RefCountedBase(T::kRefCountPreference) {}

    ~RefCounted() {}
};

template<typename T>
class RefCountedThreadSafe : public subtle::RefCountedThreadSafeBase {
AT_MAKE_NONCOPYABLE(RefCountedThreadSafe);
AT_MAKE_FAST_ALLOCATED;

public:
    static constexpr subtle::StartRefCountFromZeroTag kRefCountPreference =
            subtle::kStartRefCountFromZeroTag;

    void deref() const {
        if (derefBase())
            delete static_cast<const T *>(this);
    }

protected:

    RefCountedThreadSafe() : subtle::RefCountedThreadSafeBase(T::kRefCountPreference) {}

    ~RefCountedThreadSafe() {}
};

}  // namespace AtomGraphics

#endif //ATOMGRAPHICS_REFCOUNTED_H
